{"output": "// web/application/handlers/add-full-no-app-directly.md (1071 bytes)\n <br> require ' vendor/autoload.php ' ;\n <br> /**\n <br> * Handles an HTTP request that contains information for registering/unregistering\n <br> * a FNA application.\n <br> *\n <br> * The service must call add_matching_service() to retrieve the matching service.\n <br> *\n <br> * @uses function_http_bundles::add_register()\n <br> */\n <br> $app = new App ();\n <br> // All GET requests that come to add_register() will be sent to this service.\n <br> $api = app -> include(' ' );\n <br> $api -> register( new DbAppAndFNAAppRegistrationService ());\n <br> // Define any services to register. We will override any present in the external\n <br> // DB have the class of .DAO .\n <br> $service = new AppAndFNAAppService ( $app , [\n <br> array ( ' host ' => ' localhost ' )\n <br> ]);\n <br> $service -> register( $app , $api );\n <br> $app -> register( $service );\n <br> $app -> register( $this );\n <br> // This application will actually register itself as a DbAppAndFNAAppRegistrationService.\n <br> // That way we will be able to hook/build our own custom registration and callback\n <br> // handlers that will be sent to the DbAppAndFNAAppRegistrationService.\n <br> public function register ()\n <br> {\n <br> return new AppAndFNAAppRegistrationService ( $api , \\ App :: toTts());\n <br> }\n <br> /**\n <br> * Create an FNA simple match API.\n <br> */\n <br> public function toTts ()\n <br> {\n <br> if ( ! isset ( $this -> api )) {\n <br> return false ;\n <br> }\n <br> if ( ! isset ( $api -> registered )) {\n <br> return false ;\n <br> }\n <br> return $this -> api -> match( $this -> name , $this -> arguments , 33 );\n <br> }\n <br> /**\n <br> * Dump the indices of registered and unregistered services.\n <br> *\n <br> * @return array Dump service indexes\n <br> */\n <br> protected function dump ( array $services )\n <br> {\n <br> $service = new AppAndFNAAppService ( $api , $services );\n <br> foreach ( $this -> registered as $service ) {\n <br> foreach ( $api -> registered as $service ) {\n <br> $components = $server_roundtrip -> getComponents( $service );\n <br> if ( is_bool ( $components instanceof FNAComponentsProvider )) {\n <br> // FNA components are DummyService or IoComponentsProvider (no third party DB)\n <br> foreach ( $components as $component ) {\n <br> $id = $component -> ref();\n <br> $component -> run( VOICE_SIMPLIFIED );\n <br> }\n <br> }\n <br> $services [ $service -> ref()][ $id ] = true ;\n <br> $services [ $service -> ref()][ $id ] = true ;\n <br> }\n <br> }\n <br> return $services ;\n <br> }\n <br> /**\n <br> * Register a custom handler to intercept MimeTags.\n <br> *\n <br> * @param IoApp $app An Io application.\n <br> */\n <br> public function registerMimeTagInterceptor ( IoApp $app )\n <br> {\n <br> if ( ! isset ( $app -> mixins[ ' $matchSpec ' ])) {\n <br> $app -> mixins[ ' $matchSpec ' ] = new MatchSpec ( FNA_MANIFEST_REGEX , FILTER_DEFAULT , DB_EXTENSION_LIMIT );\n <br> }\n <br> $matchSpec = type_match_pattern ( time ( ' mgmt ' ), $sql , $app -> use__gethostname());\n <br> $match = new MimeTagFilter ( $matchSpec , $this , $app );\n <br> $match -> inputs = $this ;\n <br> // Sets the readystate for the match with the Perl DOM event.\n <br> AddNodeState ( $this -> root , ' readyState ' , function () {\n <br> $this -> cacheFunctionContract () -> XML -> registerMimeMapping( FNA_MULTIPROCESS_VIA_DOM_TAG , $match -> getValue());\n <br> });\n <br> WriteEvent ( FNA_DOM_MULTIPROCESS );\n <br> }\n <br> /**\n <br> * Register the pipe handlers that correctly connects signaling to the network,\n <br> * returns their ports.\n <br> */\n <br> public function registerPipeHandlerInterceptor\n <br>"}